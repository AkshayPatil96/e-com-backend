import { Model, model, Query, Schema, Types } from "mongoose";
import { ICategory } from "../@types/category.type";
import ErrorHandler from "../utils/ErrorHandler";
import { convertToSlug } from "../utils/logic";
import Product from "./product.model";
import { ImageSchema, metaDataSchema } from "./schema/common.model";

// Utility function to generate slug and path
const generateSlugAndPath = async (
  name: string,
  parentId: string | null,
): Promise<{ slug: string; path: string; ancestors: string[] }> => {
  let path = name;
  let slug = convertToSlug(name);
  let ancestors: string[] = [];

  if (parentId) {
    const parentCategory = await Category.findById(parentId).exec();
    if (parentCategory) {
      ancestors = [
        ...parentCategory.ancestors.map((id) => id.toString()),
        parentCategory._id.toString(),
      ];
      path = `${parentCategory.path} > ${name}`;
      slug = convertToSlug(`${parentCategory.name} ${name}`);
    }
  }

  return { slug, path, ancestors };
};

// Extend the Mongoose Model interface to include the static method
interface ICategoryModel extends Model<ICategory> {
  findActiveCategories(
    additionalQuery?: Record<string, any>,
  ): Query<ICategory[], ICategory>;
  findActiveOne(query: Record<string, any>): Query<ICategory | null, ICategory>;
}

const categorySchema = new Schema<ICategory>(
  {
    order: { type: Number },
    name: { type: String, required: true },
    slug: { type: String, unique: true },
    parent: { type: Schema.Types.ObjectId, ref: "Category", default: null },
    ancestors: [{ type: Schema.Types.ObjectId, ref: "Category" }],
    path: { type: String },
    attributes: { type: Map, of: String },
    brands: [
      {
        type: Schema.Types.ObjectId,
        ref: "Brand",
      },
    ],
    metadata: { type: metaDataSchema },
    images: [ImageSchema],
    banner: ImageSchema,
    description: { type: String },
    searchKeywords: [{ type: String }],
    isFeatured: { type: Boolean, default: false },
    createdBy: {
      type: Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    updatedBy: {
      type: Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    isDeleted: { type: Boolean, default: false },
  },
  { timestamps: true },
);

// Index on the isDeleted field to improve query performance when filtering categories.
categorySchema.index({ isDeleted: 1 });
categorySchema.index(
  { name: "text", description: "text" },
  { weights: { name: 5, description: 1 } },
);

/**
 * Pre-save middleware to generate slug and path for the category.
 * If the category has a parent, the path is constructed as parent > category.
 * The slug is generated by converting the path to a URL-friendly string.
 */
categorySchema.pre("save", async function (next) {
  const { slug, path, ancestors } = await generateSlugAndPath(
    this.name,
    this.parent ? this.parent.toString() : null,
  );
  console.log("slug: ", slug);
  console.log("path: ", path);
  console.log("ancestors: ", ancestors);
  this.metadata.title = this.metadata.title ? this.metadata.title : this.name;
  this.slug = slug;
  this.path = path;
  this.ancestors = ancestors.map((id) => new Types.ObjectId(id));

  next();
});

/**
 * Pre-update middleware to generate slug and path for the category.
 * If the category has a parent, the path is constructed as parent > category.
 * The slug is generated by converting the path to a URL-friendly string.
 */
categorySchema.pre("findOneAndUpdate", async function (next) {
  const update = this.getUpdate() as Partial<ICategory>;

  if (update.name || update.parent) {
    const { slug, path, ancestors } = await generateSlugAndPath(
      update.name || "",
      update.parent ? update.parent.toString() : null,
    );
    update.slug = slug;
    if (!update.metadata) {
      update.metadata = { title: update.name || "" };
    }
    update.path = path;
    update.ancestors = ancestors.map((id) => new Types.ObjectId(id));
  }

  next();
});

/**
 * Pre-delete middleware to prevent deletion of categories with subcategories or associated products.
 * It checks if the category has subcategories or associated products before deletion.
 */
categorySchema.pre("findOneAndDelete", async function (next) {
  const query = this.getQuery();
  const categoryId = query._id;

  const subcategories = await Category.find({
    ancestors: { $in: [categoryId] },
  }).exec();

  if (subcategories.length)
    return next(
      new ErrorHandler(400, "Cannot delete category with subcategories"),
    );

  const products = await Product.find({ category: categoryId }).exec();
  if (products.length)
    return next(
      new ErrorHandler(400, "Cannot delete category with associated products"),
    );

  next();
});

/**
 * Soft delete a category by setting isDeleted to true.
 */
categorySchema.methods.softDelete = async function (): Promise<void> {
  const subcategories = await Category.find({
    ancestors: { $in: [this._id] },
  }).exec();
  if (subcategories.length)
    throw new ErrorHandler(400, "Cannot delete category with subcategories");

  const products = await Product.find({ category: this._id }).exec();
  if (products.length)
    throw new ErrorHandler(
      400,
      "Cannot delete category with associated products",
    );

  this.isDeleted = true;
  await this.save();
};

/**
 * Restore a soft-deleted category by setting isDeleted to false.
 */
categorySchema.methods.restore = async function (): Promise<void> {
  this.isDeleted = false;
  await this.save();
};

/**
 * Static method to find all active categories based on the query.
 */
categorySchema.statics.findActiveCategories = function (
  additionalQuery: Record<string, any> = {},
): Query<ICategory[], ICategory> {
  const query = { isDeleted: false, ...additionalQuery };
  return this.find(query);
};

/**
 * Static method to find the first active category based on the query.
 */
categorySchema.statics.findActiveOne = function (
  query: Record<string, any>,
): Query<ICategory | null, ICategory> {
  return this.findOne({ ...query, isDeleted: false });
};

const Category: ICategoryModel = model<ICategory, ICategoryModel>(
  "Category",
  categorySchema,
);

export default Category;
